{"ast":null,"code":"import { useRef, useCallback, useMemo } from 'react';\nimport { createObserver, observeElement, unobserveElement } from './observer';\nimport { thresholdCacheKey } from './utils';\n\nvar noop = function () {};\n/**\n * useIntersectionObserver hook that has almost the same api as <Observer />\n *\n * @param {ChangeHandler} onChange Function that will be invoked whenever the intersection value for this element changes.\n * @param {Options} options Option to customize instersction observer instance or disable it\n *\n * @example\n * const App = () => {\n *   const onChange = ({ isIntersecting }) => console.log({ isIntersecting })\n *   const ref = useIntersectionObserver(onChange)\n *\n *   return <div ref={ref} />\n * }\n */\n\n\nexport var useIntersectionObserver = function (\n/**\n * Function that will be invoked whenever the intersection value for this element changes.\n */\nonChange, _a) {\n  var _b = _a === void 0 ? {} : _a,\n      root = _b.root,\n      rootMargin = _b.rootMargin,\n      threshold = _b.threshold,\n      disabled = _b.disabled;\n\n  var observingRef = useRef(false);\n  var instanceRef = useRef({\n    // unobserve function needs an instance and instance.handleChange needs an unobserve to be caught by closure.\n    // So it's essentially a circular reference that's resolved by assigning handleChange later\n    handleChange: function (event) {\n      /* istanbul ignore next line */\n      onChange(event, noop);\n    }\n  });\n  var unobserve = useCallback(function () {\n    if (instanceRef.current.target && observingRef.current) {\n      unobserveElement(instanceRef.current, instanceRef.current.target);\n      observingRef.current = false;\n    }\n  }, []);\n\n  instanceRef.current.handleChange = function handleChange(event) {\n    /* istanbul ignore next line */\n    onChange(event, unobserve);\n  };\n\n  var observe = function () {\n    if (instanceRef.current.observer && instanceRef.current.target && !observingRef.current) {\n      observeElement(instanceRef.current);\n      observingRef.current = true;\n    }\n  };\n\n  var memoizedThreshold = useMemo(function () {\n    return threshold;\n  }, [thresholdCacheKey(threshold)]);\n  var observer = useMemo(function () {\n    if (disabled) {\n      unobserve();\n      instanceRef.current.observer = undefined;\n      return undefined;\n    }\n\n    var rootOption = typeof root === 'string' ? document.querySelector(root) : root;\n    var obs = createObserver({\n      root: rootOption,\n      rootMargin: rootMargin,\n      threshold: memoizedThreshold\n    });\n    instanceRef.current.observer = obs;\n    unobserve();\n    observe();\n    return obs;\n  }, [root, rootMargin, memoizedThreshold, disabled]);\n  var setRef = useCallback(function (node) {\n    var isNewNode = node != null && instanceRef.current.target !== node;\n\n    if (!observer) {\n      unobserve();\n    }\n\n    if (isNewNode) {\n      unobserve();\n      instanceRef.current.target = node;\n      observe();\n    }\n\n    if (!node) {\n      unobserve();\n      instanceRef.current.target = undefined;\n    }\n  }, [observer]);\n  return [setRef, unobserve];\n};","map":{"version":3,"sources":["/Users/jordengerovac/Desktop/Programming/BrowserExtensionProjects/redux-tabsolute/node_modules/@researchgate/react-intersection-observer/lib/es/hook.js"],"names":["useRef","useCallback","useMemo","createObserver","observeElement","unobserveElement","thresholdCacheKey","noop","useIntersectionObserver","onChange","_a","_b","root","rootMargin","threshold","disabled","observingRef","instanceRef","handleChange","event","unobserve","current","target","observe","observer","memoizedThreshold","undefined","rootOption","document","querySelector","obs","setRef","node","isNewNode"],"mappings":"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","sourcesContent":["import { useRef, useCallback, useMemo } from 'react';\nimport { createObserver, observeElement, unobserveElement } from './observer';\nimport { thresholdCacheKey } from './utils';\nvar noop = function () { };\n/**\n * useIntersectionObserver hook that has almost the same api as <Observer />\n *\n * @param {ChangeHandler} onChange Function that will be invoked whenever the intersection value for this element changes.\n * @param {Options} options Option to customize instersction observer instance or disable it\n *\n * @example\n * const App = () => {\n *   const onChange = ({ isIntersecting }) => console.log({ isIntersecting })\n *   const ref = useIntersectionObserver(onChange)\n *\n *   return <div ref={ref} />\n * }\n */\nexport var useIntersectionObserver = function (\n/**\n * Function that will be invoked whenever the intersection value for this element changes.\n */\nonChange, _a) {\n    var _b = _a === void 0 ? {} : _a, root = _b.root, rootMargin = _b.rootMargin, threshold = _b.threshold, disabled = _b.disabled;\n    var observingRef = useRef(false);\n    var instanceRef = useRef({\n        // unobserve function needs an instance and instance.handleChange needs an unobserve to be caught by closure.\n        // So it's essentially a circular reference that's resolved by assigning handleChange later\n        handleChange: function (event) {\n            /* istanbul ignore next line */\n            onChange(event, noop);\n        },\n    });\n    var unobserve = useCallback(function () {\n        if (instanceRef.current.target && observingRef.current) {\n            unobserveElement(instanceRef.current, instanceRef.current.target);\n            observingRef.current = false;\n        }\n    }, []);\n    instanceRef.current.handleChange = function handleChange(event) {\n        /* istanbul ignore next line */\n        onChange(event, unobserve);\n    };\n    var observe = function () {\n        if (instanceRef.current.observer &&\n            instanceRef.current.target &&\n            !observingRef.current) {\n            observeElement(instanceRef.current);\n            observingRef.current = true;\n        }\n    };\n    var memoizedThreshold = useMemo(function () { return threshold; }, [\n        thresholdCacheKey(threshold),\n    ]);\n    var observer = useMemo(function () {\n        if (disabled) {\n            unobserve();\n            instanceRef.current.observer = undefined;\n            return undefined;\n        }\n        var rootOption = typeof root === 'string' ? document.querySelector(root) : root;\n        var obs = createObserver({\n            root: rootOption,\n            rootMargin: rootMargin,\n            threshold: memoizedThreshold,\n        });\n        instanceRef.current.observer = obs;\n        unobserve();\n        observe();\n        return obs;\n    }, [root, rootMargin, memoizedThreshold, disabled]);\n    var setRef = useCallback(function (node) {\n        var isNewNode = node != null && instanceRef.current.target !== node;\n        if (!observer) {\n            unobserve();\n        }\n        if (isNewNode) {\n            unobserve();\n            instanceRef.current.target = node;\n            observe();\n        }\n        if (!node) {\n            unobserve();\n            instanceRef.current.target = undefined;\n        }\n    }, [observer]);\n    return [setRef, unobserve];\n};\n"]},"metadata":{},"sourceType":"module"}