{"ast":null,"code":"import { parseRootMargin, shallowCompare } from './utils';\nexport var observerElementsMap = new Map();\nexport function getPooled(options) {\n  if (options === void 0) {\n    options = {};\n  }\n\n  var root = options.root || null;\n  var rootMargin = parseRootMargin(options.rootMargin);\n  var threshold = Array.isArray(options.threshold) ? options.threshold : [options.threshold != null ? options.threshold : 0];\n  var observers = observerElementsMap.keys();\n  var observer;\n\n  while (observer = observers.next().value) {\n    var unmatched = root !== observer.root || rootMargin !== observer.rootMargin || shallowCompare(threshold, observer.thresholds);\n\n    if (!unmatched) {\n      return observer;\n    }\n  }\n\n  return null;\n}\nexport function findObserverElement(observer, entry) {\n  var elements = observerElementsMap.get(observer);\n\n  if (elements) {\n    var values = elements.values();\n    var element = void 0;\n\n    while (element = values.next().value) {\n      if (element.target === entry.target) {\n        return element;\n      }\n    }\n  }\n\n  return null;\n}\n/**\n * The Intersection Observer API callback that is called whenever one element\n * – namely the target – intersects either the device viewport or a specified element.\n * Also will get called whenever the visibility of the target element changes and\n * crosses desired amounts of intersection with the root.\n */\n\nexport function callback(entries, observer) {\n  for (var i = 0; i < entries.length; i++) {\n    var element = findObserverElement(observer, entries[i]);\n    /* istanbul ignore next line */\n\n    if (element) {\n      element.handleChange(entries[i]);\n    }\n  }\n}\nexport function createObserver(options) {\n  var pooled = getPooled(options);\n\n  if (pooled) {\n    return pooled;\n  }\n\n  var observer = new IntersectionObserver(callback, options);\n  observerElementsMap.set(observer, new Set());\n  return observer;\n}\nexport function observeElement(element) {\n  var _a;\n\n  if (element.observer && !observerElementsMap.has(element.observer)) {\n    observerElementsMap.set(element.observer, new Set());\n  }\n\n  (_a = observerElementsMap.get(element.observer)) === null || _a === void 0 ? void 0 : _a.add(element);\n  element.observer.observe(element.target);\n}\nexport function unobserveElement(element, target) {\n  if (observerElementsMap.has(element.observer)) {\n    var targets = observerElementsMap.get(element.observer);\n\n    if (targets === null || targets === void 0 ? void 0 : targets.delete(element)) {\n      if (targets.size > 0) {\n        element.observer.unobserve(target);\n      } else {\n        element.observer.disconnect();\n        observerElementsMap.delete(element.observer);\n      }\n    }\n  }\n}","map":{"version":3,"sources":["/Users/jordengerovac/Desktop/Programming/BrowserExtensionProjects/redux-tabsolute/node_modules/@researchgate/react-intersection-observer/lib/es/observer.js"],"names":["parseRootMargin","shallowCompare","observerElementsMap","Map","getPooled","options","root","rootMargin","threshold","Array","isArray","observers","keys","observer","next","value","unmatched","thresholds","findObserverElement","entry","elements","get","values","element","target","callback","entries","i","length","handleChange","createObserver","pooled","IntersectionObserver","set","Set","observeElement","_a","has","add","observe","unobserveElement","targets","delete","size","unobserve","disconnect"],"mappings":"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","sourcesContent":["import { parseRootMargin, shallowCompare } from './utils';\nexport var observerElementsMap = new Map();\nexport function getPooled(options) {\n    if (options === void 0) { options = {}; }\n    var root = options.root || null;\n    var rootMargin = parseRootMargin(options.rootMargin);\n    var threshold = Array.isArray(options.threshold)\n        ? options.threshold\n        : [options.threshold != null ? options.threshold : 0];\n    var observers = observerElementsMap.keys();\n    var observer;\n    while ((observer = observers.next().value)) {\n        var unmatched = root !== observer.root ||\n            rootMargin !== observer.rootMargin ||\n            shallowCompare(threshold, observer.thresholds);\n        if (!unmatched) {\n            return observer;\n        }\n    }\n    return null;\n}\nexport function findObserverElement(observer, entry) {\n    var elements = observerElementsMap.get(observer);\n    if (elements) {\n        var values = elements.values();\n        var element = void 0;\n        while ((element = values.next().value)) {\n            if (element.target === entry.target) {\n                return element;\n            }\n        }\n    }\n    return null;\n}\n/**\n * The Intersection Observer API callback that is called whenever one element\n * – namely the target – intersects either the device viewport or a specified element.\n * Also will get called whenever the visibility of the target element changes and\n * crosses desired amounts of intersection with the root.\n */\nexport function callback(entries, observer) {\n    for (var i = 0; i < entries.length; i++) {\n        var element = findObserverElement(observer, entries[i]);\n        /* istanbul ignore next line */\n        if (element) {\n            element.handleChange(entries[i]);\n        }\n    }\n}\nexport function createObserver(options) {\n    var pooled = getPooled(options);\n    if (pooled) {\n        return pooled;\n    }\n    var observer = new IntersectionObserver(callback, options);\n    observerElementsMap.set(observer, new Set());\n    return observer;\n}\nexport function observeElement(element) {\n    var _a;\n    if (element.observer && !observerElementsMap.has(element.observer)) {\n        observerElementsMap.set(element.observer, new Set());\n    }\n    (_a = observerElementsMap.get(element.observer)) === null || _a === void 0 ? void 0 : _a.add(element);\n    element.observer.observe(element.target);\n}\nexport function unobserveElement(element, target) {\n    if (observerElementsMap.has(element.observer)) {\n        var targets = observerElementsMap.get(element.observer);\n        if (targets === null || targets === void 0 ? void 0 : targets.delete(element)) {\n            if (targets.size > 0) {\n                element.observer.unobserve(target);\n            }\n            else {\n                element.observer.disconnect();\n                observerElementsMap.delete(element.observer);\n            }\n        }\n    }\n}\n"]},"metadata":{},"sourceType":"module"}